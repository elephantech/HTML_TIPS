<!DOCTYPE html>

<html lang="ja">
<!-- --------------------------------------
head
--------------------------------------- -->
<head>
<meta content="text/html" charset="utf-8" http-equiv="Content-Type" />

<!-- 基準URI -->
<base href="file:///G:/共有ドライブ/098-all-employees/tips/HTML_TIPS/">

<!-- スタイルシート -->
<link rel="stylesheet" href="_Assets/Sytle001.css" type="text/css">

<!-- スクリプト -->
<!-- タイトル表示 -->
<script src="_Assets/MakeTitle.js" type="text/javascript"></script>
<!-- 目次表示 -->
<script src="_Assets/MakeToc_L.js" type="text/javascript"></script>

</head>

<!-- --------------------------------------
body
--------------------------------------- -->
<body>
<!-- ページタイトル(ページ内表示) -->
<span id="title"></span>

<!-- 出典・関連ページ -->
<h5>出典 :</h5>
<a href="https://qiita.com/4_mio_11/items/f9b19c04509328b1e5c1">非同期理解のためにasync/awaitとTaskの基礎を学んだ話 - Qiita</a><br>
<a href="https://qiita.com/acple@github/items/8f63aacb13de9954c5da">Taskを極めろ！async/await完全攻略 - Qiita</a><br>
<a href="https://qiita.com/rawr/items/5d49960a4e4d3823722f">C# 今更ですが、await / async - Qiita</a><br>

<!-- 目次 -->
<h5>目次 :</h5>
<div id="toc"></div>

<hr>

<!-- 本文ここから -->


<h2>async と await による非同期処理実装</h2>
<p class="code">
    <kwd>class</kwd> Program
    {
        <kwd>static string</kwd> text = <kwd>string</kwd>.Empty;

        <cmt>// 重い処理</cmt>
        <kwd>private static double</kwd> HeavyWork(<kwd>int</kwd> n)
        {
            <kwd>return</kwd> Enumerable.Range(<ltr>1</ltr>, n).Sum(i => <ltr>1</ltr> / (<kwd>double</kwd>)i) - Math.Log(n);
        }

        <cmt>// 重い処理を非同期実行</cmt>
        <cmt>// (関数内で await を使用するため async 修飾、戻り値は Task)</cmt>
        <kwd>private</kwd> async <kwd>static</kwd> Task ExecuteAsync()
        {
            text += <ltr>"計算開始"</ltr> + Environment.NewLine;

            <cmt>// 重い処理を別タスクで実行開始(Task.Run())
            // await 修飾により、呼び元に処理を戻すとともに
            // 次行以降はタスクの完了を待機した後に実行する</cmt>
            <kwd>double</kwd> result = await Task.Run(() =>  HeavyWork(<ltr>2000000000</ltr>));

            <cmt>// 結果表示</cmt>
            <cmt>// 別タスク実行された HeavyWork() の完了後に実行される</cmt>
            text += result.ToString() + Environment.NewLine;
        }

        <cmt>// メイン関数</cmt>
        <kwd>static void</kwd> Main(<kwd>string</kwd>[] args)
        {
            <cmt>// 重い処理を非同期実行</cmt>
            Task task = ExecuteAsync();

            <cmt>// タスクが完了するまで経過を表示</cmt>
            <kwd>while</kwd> (!task.IsCompleted)
            {
                Task.Delay(<ltr>1000</ltr>).Wait();

                Console.SetCursorPosition(<ltr>0</ltr>, <ltr>0</ltr>);

                <kwd>if</kwd> (!task.IsCompleted)
                {
                    text += <ltr>"..."</ltr> + Environment.NewLine;
                }

                Console.WriteLine(text);
            }

            Console.ReadKey();
        }
    }
</p>

<h3>await</h3>
<b>await</b> は、<b>「続く Task を非同期的に実行(開始)し、終了を待機する」</b>ことを表す。<br>
これにより、await 修飾された行の後続行は、Task の完了後に実行される。<br>
さらに、<b>await キーワードに到達した時点で、呼び出し元に処理を戻す</b>点が task.Wait() とは異なる。<br>

<h3>async</h3>
<b>async</b> は、<b>「その関数中で await を使用する (= 非同期処理を開始する)」</b>ことを表す。<br>
async 修飾の際は原則として戻り値を<b>Task</b>とする。<br>
(非同期実行したタスクの状態を監視するため)<br>
<ul>
<li>元々の戻り値がvoid ⇒ async Task</li>
<li>元々の戻り値がT型 ⇒ async Task&lt;T&gt;</li>
</ul>
Task を明示的に return する必要は無い。<br>
<b>UIから直接実行されるイベントハンドラは例外的に async void を用いる</b>。<br>

<h2>例外処理について</h2>
<p class="code">
<cmt>// イベントハンドラ</cmt>
<kwd>private</kwd> async <kwd>void</kwd> button_Click(object sender, EventArgs e)
{
    <kwd>try</kwd>
    {
        <cmt>// スレッドを起動し、終了を待機</cmt>
        Task[] allTasks = <kwd>new</kwd> Task[NUM_TASKS];
        <kwd>for</kwd> (<kwd>int</kwd> i = <ltr>0</ltr>; i &lt; NUM_TASKS; i++)
        {
            allTasks [i] = Task.Run(() =&gt; SubThread());
        }
        await Task.WhenAll(allTasks );
    }
    <cmt>// 例外発生時はメッセージを表示</cmt>
    <kwd>catch</kwd>(Exception ex)
    {
        MsgBoxFunc.ShowErrMsgBox(ex.Message);
    }
}

<cmt>// サブスレッド</cmt>
<kwd>private void</kwd> SubThread()
{
    <kwd>throw new</kwd> Exception(<ltr>"例外発生！"</ltr>);
}
</p>
サブスレッドでの例外を捕捉するには、上記のように起動～終了待ちを try 節で囲むとよい。<br>
但し、<b>デバッグ実行を行った場合は例外を正常に捕捉できない点に注意</b>。<br>
</body>
</html>


