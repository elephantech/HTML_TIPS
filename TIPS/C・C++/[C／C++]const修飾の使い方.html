<!DOCTYPE html>

<html lang="ja">
<!-- --------------------------------------
head
--------------------------------------- -->
<head>
<meta content="text/html" charset="utf-8" http-equiv="Content-Type" />

<!-- 基準URI -->
<base href="file:///G:/共有ドライブ/098-all-employees/tips/HTML_TIPS/">

<!-- スタイルシート -->
<link rel="stylesheet" href="_Assets/Sytle001.css" type="text/css">

<!-- スクリプト -->
<!-- タイトル表示 -->
<script src="_Assets/MakeTitle.js" type="text/javascript"></script>
<!-- 目次表示 -->
<script src="_Assets/MakeToc.js" type="text/javascript"></script>

</head>

<!-- --------------------------------------
body
--------------------------------------- -->
<body>
<!-- ページタイトル(ページ内表示) -->
<span id="title"></span>
<span id="title"></span>

<!-- 出典・関連ページ -->
<h5>出典 :</h5>
<a href="http://kumikomiya.com/act-professionally-with-const/">const を使いこなそう - 組込屋</a><br>

<h5>関連 :</h5>
<a href="TIPS/C・C++/[C／C++]static修飾の使い方.html">[C／C++]static修飾の使い方</a><br>
<a href="TIPS/C・C++/[C++]コンストラクタ初期化子(初期化リスト).html">[C++]コンストラクタ初期化子(初期化リスト)</a><br>

<!-- 目次 -->
<h5>目次 :</h5>
<div id="toc"></div>

<hr>

<!-- 本文ここから -->

<h2>const修飾とは</h2>
修飾する対象が <b>不変</b> であることを示すこと。<br>
「変更できない( = 変更されてはならない)」ことを明示することで、データの予期しない変更を防ぐことができるとともに、<br>
対象が入力値としてのみ用いられることが判別しやすくなり、コードの安全性・可読性が高まる。<br>
static修飾との混同に注意。<br>

<h2>const修飾の類型</h2>

<h3>ポインタを修飾する</h3>
 <strong>アスタリスクより左に</strong> constキーワードを置くと、 <strong>当該ポインタが「指し示す先が」読み取り専用となる</strong> 。<br>
<p class="code">
<keyword>const</keyword> <keyword>char</keyword>* p;  <comment>/* const修飾されたポインタ変数 */</comment>

<comment>/* 以下の処理は許容されない(コンパイルが通らない) */</comment>
*p = <literal>'\<literal>0</literal>'</literal>;
p[<literal>15</literal>] = <literal>0</literal>;
</p>
<h3>参照を修飾する</h3>
ポインタ修飾と同様、 <strong>参照変数の「指し示す先が」読み取り専用となる</strong> 。<br>
<p class="code">
<comment>// lhs , rhs の値が関数内で書き換えられないことが保証される</comment>
TimeSpan subtract(<keyword>const</keyword> DateTime &amp;lhs, <keyword><keyword>const</keyword></keyword> DateTime &amp;rhs);
</p>
<h3>永続的な変数を修飾する</h3>
グローバル変数、およびstatic修飾されたローカル変数をconst修飾すると、単に代入ができないだけでなく、 <strong>当該変数がROMに配置されるようになる</strong> 。<br>
⇒  <strong>RAM(スタック)の使用量を削減することができる</strong> 。<br>
<p class="code">
<comment>/* const修飾されているため、ROMに配置される */</comment>
<keyword>const</keyword> <keyword>short</keyword> tbl_1[<literal>8</literal>] = {  <literal>1</literal>, <literal>2</literal>, <literal>3</literal>, <literal>4</literal>, <literal>5</literal>, <literal>6</literal>, <literal>7</literal>, <literal><literal>8</literal></literal> };

<comment>/* const修飾が無いため、RAMを使用する */</comment>
<keyword>short</keyword> tbl_2[<literal>8</literal>] = {  <literal>1</literal>, <literal>2</literal>, <literal>3</literal>, <literal>4</literal>, <literal>5</literal>, <literal>6</literal>, <literal>7</literal>, <literal><literal>8</literal></literal> };
</p>
定数配列(テーブル)はconst修飾しなければ、RAMを大量に消費することになる。<br>
 <strong>特に組み込み用途においてはRAMに余裕が無いことが多いため、「テーブルはconst修飾」は鉄則として理解されたい。</strong> <br>
<h4>永続的変数がポインタの場合</h4>
constキーワードを <strong>「アスタリスクの右」に置かないとROM配置の指示とはならない</strong> 。<br>
<p class="code">
IPortOutput* <keyword>const</keyword> g_nanaseg1[<literal>8</literal>] = {
  &amp;g_port20, &amp;g_port21, &amp;g_port40, &amp;g_port41,
  &amp;g_port76, &amp;g_port77, &amp;g_port34, &amp;g_port35,
};
</p>

<h3>メンバ変数を修飾する</h3>
<p class="code">
<keyword>class</keyword> Real
{
  <keyword>private</keyword>:
    <keyword>const</keyword> <keyword>double</keyword> m_val;  <comment>//&lt; const修飾されたメンバ変数</comment>
  <keyword>public</keyword>:
    Real(<keyword>double</keyword> val) : m_val(val) { }  <comment>//&lt; m_val は初期化子リストにて初期化されなければならない</comment>
};
</p>
クラスのメンバ変数をconst修飾した場合、 <strong>当該変数はコンストラクタ初期化子を用いて「必ず」初期化されなければならなくなる</strong> 。<br>
⇒  <strong>生成時点で値が定められ(「不定」が認められず)、かつ生涯不変の「性質」を設定する際に有効。</strong> <br>
<br>
const修飾を用いずに記述した場合は以下のようになる。<br>
<p class="code">
<keyword>class</keyword> Real
{
  <keyword>private</keyword>:
    <keyword>double</keyword> m_val;
  <keyword>public</keyword>:
    Real(<keyword>double</keyword> val) { m_val = val; }  <comment>//&lt; m_val をコンストラクタ中で初期化(厳密には代入)することは必須ではない</comment>
};
</p>
この場合、 m_val がインスタンス生成時に初期化されるかどうかはコンストラクタの実装(≒良心)に依存し、<br>
またインスタンスの生存期間中に値が更新されてもエラーとはならない。<br>
即ち、「生成時に値が定まっていること」、および「生涯不変であること」が保証されない。<br>
⇒  <strong>const修飾を用いることで、生涯不変の「性質」と、変化し得る「状態」を区分できる。</strong> <br>
<br>
コンストラクタ初期化子については<a href="TIPS/C・C++/[C++]コンストラクタ初期化子(初期化リスト).html">[C++]コンストラクタ初期化子(初期化リスト)</a>を参照のこと。<br>

<h3>メンバ関数を修飾する</h3>
<p class="code">
<keyword>class</keyword> File
{
<keyword>public</keyword>:
  <keyword>bool</keyword> isEnd() <keyword>const</keyword>;
  <keyword>char</keyword> get() <keyword>const</keyword>;
};
</p>
<b>引数リスト(括弧)の右にconstを置く</b>。<br>
const修飾されたメンバ関数は、メンバ変数を更新することができなくなる。<br>
⇒  <strong>インスタンスの「状態」が(暗黙的に)変更されることが無いことが保証される。</strong> <br>
ここで、 <strong>const修飾されたメンバ関数からは、同様にconst修飾されたメンバ関数しかコールすることができない</strong> 点に留意されたい。<br>
<h3>一時的な変数を修飾する</h3>
関数の引数、およびstatic修飾の無いローカル変数(自動変数)に対するconst修飾は、単に「代入を許容しない」という意味となる。<br>
<p class="code">
<comment>// 引数および自動変数をconst修飾</comment>
<keyword>bool</keyword> isClockwise(<keyword>const</keyword> <keyword>uint32_t</keyword> a, <keyword>const</keyword> <keyword>uint32_t</keyword> b)
{
  <keyword>const</keyword> <keyword>uint32_t</keyword> diff = b - a;    <cmt>//< 初期化(代入ではない)は可</cmt>
  <keyword>return</keyword> (diff &amp; <literal>0x80000000U</literal>) != <literal>0</literal>;
}
</p>
</body>
</html>

