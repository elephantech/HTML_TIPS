<!DOCTYPE html>

<html lang="ja">
<!-- --------------------------------------
head
--------------------------------------- -->
<head>
<meta content="text/html" charset="utf-8" http-equiv="Content-Type" />

<!-- 基準URI -->
<base href="https://elephantech-html-tips-etc.on.drv.tw/HTML_TIPS/">

<!-- スタイルシート -->
<link rel="stylesheet" href="_Assets/CSS/Sytle001.css" type="text/css">

<!-- スクリプト -->
<!-- タイトル表示 -->
<script src="_Assets/MakeTitle.js" type="text/javascript"></script>
<!-- 目次表示 -->
<script src="_Assets/MakeToc_L.js" type="text/javascript"></script>



</head>

<!-- --------------------------------------
body
--------------------------------------- -->
<body>
<!-- ページタイトル(ページ内表示) -->
<span id="title"></span>

<!-- 出典・関連ページ -->
<h5>出典 :</h5>
<a href="https://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%B3%E3%83%81%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3">アンチパターン - Wikipedia</a><br>
<a href="https://qiita.com/peutes/items/ad046baa2428b522a133">やめた方が良いコーディング・設計、アンチパターン - Qiita</a><br>

<h5>関連 :</h5>
<a href="TIPS/ソフトウェア開発一般/Don%27t%20Repeat%20Yourself%20(DRY).html">Don't Repeat Yourself (DRY)</a><br>
<a href="TIPS/ソフトウェア開発一般/%E6%A7%8B%E9%80%A0%E5%8C%96%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0.html">構造化プログラミング</a><br>
<a href="TIPS/ソフトウェア開発一般/%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88%E9%A7%86%E5%8B%95%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0.html">イベント駆動型プログラミング</a><br>
<a href="TIPS/ソフトウェア開発一般/[%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91]SOLID%E3%81%AE%E5%8E%9F%E5%89%87.html">[オブジェクト指向]SOLIDの原則</a><br>

<!-- 目次 -->
<h5>目次 :</h5>
<div id="toc"></div>

<hr>

<!-- 本文ここから -->


<h2>アンチパターンとは</h2>
必ず否定的な結果に到達する、それでいて一般的によく見られる手法(不適切な解決策)のこと。<br>
デザインパターンを構築する上での反面教師となる。<br>

<h2>アンチパターンの類型</h2>
ここに挙げたもの以外は出典元を参照。<br>

<h3>肥満児</h3>
肥大化したオブジェクト。 <b>一つのモジュール(オブジェクト指向ではクラス)に複数の機能を詰め込んだ結果発生する</b> 。<br>
⇒ 一つのモジュール(またはクラス)が複数の機能を担う場合は、機能ごとにサブモジュール(サブクラス)を作成することで肥大化を避ける。委譲を用いるのも効果的。<br>

<h3>スパゲッティコード</h3>
構造がほとんど理解できないようなシステム。 <b>GOTO(無条件分岐)を多用するなどで、論理構造が破壊されたことで発生する</b>。<br>
⇒ 無条件分岐を用いない論理設計を行う。一つのルーチンが長大化したことでスパゲッティコードとなることが多いので、サブルーチンに分割する。<br>

<h3>切り貼りプログラミング</h3>
汎用的なコードを作らず、 <b>既存のコードをコピー・ペーストして使う</b> 。<br>
同様の処理がプログラムの各所に分散し、修正する手間が増えたり、同期がとれなくなる。<br>
⇒ <b>複数回(2回以上)現れる共通の論理はサブルーチン化する(Don't Repeat Yourselfの原則)</b>。<a href="TIPS/ソフトウェア開発一般/Don%27t%20Repeat%20Yourself%20(DRY).html">Don't Repeat Yourself (DRY)</a>を参照。<br>

<h3>打ち出の小槌・銀の弾丸</h3>
気に入った方法が、あらゆるところで利用できる、あるいは万能だと思い込む。<br>
適用すべきでない局面に無理やり適用する、そもそも「気に入った」だけで合理的でない、などで他者の理解を妨げるとともに整備性を低下させる。<br>
⇒ その手法自体の合理性、および適用すべき場面を吟味し、不適切な場面には用いない。<br>

<h3>組織硬直</h3>
多くの人間が設計に関与しているが、統一された考え方が存在しない。<br>
⇒ 組織におけるデザインルールを明確化するとともに、各人が意識的にルールを順守する。設計書・ソースコード共に、設計思想が他者に伝わることを重視して記述する。<br>

<h3>車輪の再発明</h3>
既に知られている適切な(一般的な)解決方法を採用しない。<br>
⇒ 同様の課題に関する一般的な解法が存在しないかを確かめるとともに、自らが考案した手法が真に合理的かを自問する(疑ってかかる)。<br>

<h3>溶岩流</h3>
除去することが非常に困難で、(除去した際の)結果が予測できないために品質の低い(多くの場合冗長で複雑長大な)コードを維持せざるを得なくなる。<br>
モジュール同士が複雑に絡み合って(相互依存して)いる、またはそもそもモジュール分割がなされていないなど、一部を修正した際の影響範囲が予測できないコード。<br>
⇒ プログラム全体の把握が可能となるよう、モジュール化を重視して構成する(入念に構造設計を行う)。一度溶岩流となった場合、再構築は非常に困難で、フルスクラッチを余儀なくされる。<br>

<h3>ビジーウェイト</h3>
何らかの事象(イベント)が発生するのを待つ際にメッセージングを使わず、繰り返し確認(ポーリング)することでCPU資源を浪費する。<br>
⇒ イベント駆動型のプログラムとし、イベントの発生はスレッド間通信(メッセージ、イベントフラグなど)を用いて検知する。
<a href="TIPS/ソフトウェア開発一般/%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88%E9%A7%86%E5%8B%95%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0.html">イベント駆動型プログラミング</a>を参照。<br>

<h3>カーゴ・カルト・プログラミング</h3>
パターンや方法論を、理由(必然性・必要性・原理)を理解せずに用いる。<br>
⇒ 自らが用いる手法について理解する。「周囲がそうしているから」「今までそうだったから」「なんとなく」は理由とならない。<br>

<h3>マジックナンバー</h3>
説明の無い数値(即値)をアルゴリズムで使用する。その値が意味するものが伝わらず、また同じ値が同じものを示しているとは限らないため、修正が必要となった際の要修正箇所の特定が困難となる。<br>
⇒  <b>プログラム中で用いる定数は(自明の場合を除き)必ずシンボルを定義する</b> 。リテラルを用いる場合はローカルスコープに留め、確実に設計書およびコメントで補足する。<br>

<h3>ボートの碇</h3>
もはや使用されていない部分をそのままにしておくこと。無効なコードが有効であるという誤解を招き、可読性・検索性が低下する。<br>
⇒ 必要のなくなったコードは削除する(<b>コメントとしても残さない</b>)。<br>

<h2>そもそものマナー違反</h2>
<h3>自分で書いたコードの推敲(セルフチェック)を行わない</h3>
コードレビューを依頼する前に、 <b>自分の書いたコードを読まないというのは論外</b> 。<br>
<b>何を書いているのかが自分でもわからないというのも論外</b> 。<br>

<h3>インデントを揃えない</h3>
最低限、 <b>ネストレベルとインデントの深さは揃える</b> 。<br>

<h3>条件分岐が多い、ネストが深い</h3>
考慮すべき条件が多くなるほどチェックが行き渡りにくくなり、考慮漏れやバグの元となる。<br>
そもそもネストが深いのは、一つの関数(メソッド)が担う責務(機能)が多すぎるため。機能単位でサブルーチン化を行うべき。<br>
条件分岐ではなくジャンプテーブルを用いることで、コードサイズも縮小でき、さらに処理速度も向上する。<br>

<h3>適切なコーディング技法(一般的な手法)を習得していない</h3>
本来 switch - case を用いるべき箇所で if - else if ... のラダーを組むなど。プロのコードとしてあり得ない。<br>
特にソフトウェアの技術は陳腐化しやすいため、学び続ける姿勢を失わないこと。<br>

<h3>コードとコメントの同期をとらない</h3>
コードを修正した際にコメントを直さない、そもそもコメントを書いていないなど。<br>
コードとコメントのどちらが正しいのかが判別できず、プログラム全体の信憑性が低下する。<br>

<h3>スペルミス</h3>
英単語のスペルくらい辞書で調べましょう。<br>
誤ったスペルが残っていると検索できず、また正しいスペルと誤ったスペルが混在していると、影響範囲を正しく特定できなくなる。

</body>
</html>
