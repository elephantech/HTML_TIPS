<!DOCTYPE html>

<html lang="ja">
<!-- --------------------------------------
head
--------------------------------------- -->
<head>
<meta content="text/html" charset="utf-8" http-equiv="Content-Type" />

<!-- 基準URI -->
<base href="https://elephantech-html-tips-etc.on.drv.tw/HTML_TIPS/">

<!-- スタイルシート -->
<link rel="stylesheet" href="_Assets/CSS/Sytle001.css" type="text/css">

<!-- スクリプト -->
<!-- タイトル表示 -->
<script src="_Assets/MakeTitle.js" type="text/javascript"></script>
<!-- 目次表示 -->
<script src="_Assets/MakeToc_L.js" type="text/javascript"></script>



</head>

<!-- --------------------------------------
body
--------------------------------------- -->
<body>
<!-- ページタイトル(ページ内表示) -->
<span id="title"></span>

<!-- 出典・関連ページ -->
<h5>出典 :</h5>
<a href="https://ja.wikipedia.org/wiki/%E6%A7%8B%E9%80%A0%E5%8C%96%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0">構造化プログラミング - Wikipedia</a><br>
<a href="https://ja.wikipedia.org/wiki/%E3%83%88%E3%83%83%E3%83%97%E3%83%80%E3%82%A6%E3%83%B3%E8%A8%AD%E8%A8%88%E3%81%A8%E3%83%9C%E3%83%88%E3%83%A0%E3%82%A2%E3%83%83%E3%83%97%E8%A8%AD%E8%A8%88">トップダウン設計とボトムアップ設計 - Wikipedia</a><br>
<a href="https://ja.wikipedia.org/wiki/%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB">モジュール - Wikipedia</a><br>
<a href="https://cyzennt.co.jp/blog/2019/03/16/%E3%80%8C%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E5%BC%B7%E5%BA%A6%E3%81%A8%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E7%B5%90%E5%90%88%E5%BA%A6%E3%80%8D%E3%81%AE%E5%9B%B3%E8%A7%A3/">「モジュール強度とモジュール結合度」の図解 – サイゼントの技術ブログ</a><br>
<a href="https://qiita.com/eKushida/items/39bdb3f88fb68ecd66f6">モジュール結合度について - Qiita</a><br>
<a href="http://www.kogures.com/hitoshi/webtext/kj2-module">モジュールの強度と結合度＜システムの調達＜Ｗｅｂ教材＜木暮</a><br>

<h5>関連 :</h5>
<a href="TIPS/ソフトウェア開発一般/Don%27t%20Repeat%20Yourself%20(DRY).html">Don't Repeat Yourself (DRY)</a><br>
<a href="TIPS/ソフトウェア開発一般/[%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91]SOLID%E3%81%AE%E5%8E%9F%E5%89%87.html">[オブジェクト指向]SOLIDの原則</a><br>
<a href="TIPS/ソフトウェア開発一般/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E3%82%A2%E3%83%B3%E3%83%81%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3.html">ソフトウェア開発におけるアンチパターン</a><br>
<a href="TIPS/C%E3%83%BBC++/[C++]%E5%9C%B0%E8%94%B5%E3%82%A4%E3%83%B3%E3%82%B9%E3%82%BF%E3%83%B3%E3%82%B9.html">[C++]地蔵インスタンス</a><br>
<a href="TIPS/C%E3%83%BBC++/[C++]%E4%BE%8B%E5%A4%96%E5%87%A6%E7%90%86.html">[C++]例外処理</a><br>

<!-- 目次 -->
<h5>目次 :</h5>
<div id="toc"></div>

<hr>

<!-- 本文ここから -->

<h2>構造化プログラミング(構造化設計)とは</h2>
コンピュータプログラミングに「構造」の概念を導入することで、開発効率と品質の向上を図るプログラミング技法のこと。<br>
1969年にエドガー・ダイクストラが発表した論文が初出。<br>
それまでの、各部品を下から一つ一つ積み上げる「ボトムアップ設計」(段階的抽象)では、各部品間の依存関係を生みやすく、プログラムの正しさを検証することが困難となっていた。<br>
(プログラム部品(モジュール)、およびそれらを組み合わせた際のプログラム正当性を証明するためのテスト回数は、モジュールが増加するごとに指数関数的に増えてゆくため。)<br>
これを受け、<b>部品間の不必要な依存関係を排除できる「トップダウン設計」(段階的詳細)</b>へのパラダイムシフトの必要性を訴えた。<br>
「トップダウン設計」(=構造化設計)が正しく行われた場合、関連の無い機能による影響を無視できるため、<br>機能単位で独立したモジュールごとに検証を行えばよく、テストの回数を抑制できるとともに、ソースコード自体の静的な検証も容易となる。<br>
尚、「構造化定理」と混同されることが多いが、無関係である。

<h2>モジュール(module)とは</h2>
<img src="_Img/Software Development/structual_programming/structual_programming_01.png"><br>
<b>ソフトウェアにおける「モジュール」は、厳密にはコンパイルの単位(Cにおけるファイル)を指す</b>。<br>
(オブジェクト指向言語におけるクラス(およびその実体であるオブジェクト、インスタンス)も広義のモジュールである。)<br>
同一ファイル内においてはグローバル変数を用いたデータの共有が可能であるため、データ共有が必要な(=機能的な結びつきが強い)関数群を一つのファイルにまとめることが基本となる。<br>
段階的詳細化の過程で、一つのモジュールが複数の小機能を含む(ことでモジュールが肥大化している)場合は、小機能ごとのモジュール分割(階層化)が求められる。<br>
(小機能ごとのサブモジュールを束ねる機能部品も同様にモジュールと呼ばれる。)<br>
<br>
モジュールは一般に、<b>「交換可能」</b>であるものとされる。即ち、
<ul>
  <li>インタフェース(入出力)仕様が明確化されている</li>
  <li>当該機能がそのモジュール単体で実現可能である</li>
</ul>
ことが重要である。相互に交換可能なモジュール同士ではインタフェースは共通しながらも、内部の実装はそれぞれで独立している。<br>
(インタフェースと実装の分離)<br>
<br>
システムの構成要素である単一のソフトウェア(プログラム)、または単一のハードウェアデバイスは、<b>「システム視点では」</b>機能部品(モジュール)と見なすことができるが、<br>
<b>「ソフトウェア視点でのモジュール」と区別するため</b>、「サブシステム」または「コンポーネント(component)」と呼ぶことが多い。<br>
(「モジュール」「コンポーネント」共に原義としては「部品」「構成要素」と大きな違いは無いが、<br>
「コンポーネント」は「全体の一部」、<b>「モジュール」は「交換可能な機能部品」</b>の意味合いが強い。)<br>

<h2>モジュール強度とモジュール結合度</h2>
構造化設計(構造化プログラミング)における設計成熟度の指標。<br>
<b>モジュール強度が強く、モジュール結合度が弱いほど、構造的に優れている</b>。<br>
両者はトレードオフではなく、むしろ正の相関がある。

<h3>モジュール強度</h3>
モジュール自身の(特に変更に対する)安定性を表す。モジュール強度が強いほど、他の機能に対する変更による影響が小さい。
<table>
  <tr class="row1">
    <td class="col1">区分</td>
    <td>説明</td>
    <td colspan="2">モジュール強度</td>
  </tr>
  <tr>
    <td class="col1">機能的強度</td>
    <td>モジュールが単一の機能のみを提供</td>
    <td bgcolor="4BFF80">強</td>
    <td rowspan="2">構造化設計の目標</td>
  </tr>
  <tr>
    <td class="col1">情報的強度</td>
    <td>特定の同じデータを扱うための機能を一つのモジュールにまとめる</td>
    <td bgcolor="69E180"></td>
  </tr>
  <tr>
    <td class="col1">連絡的強度</td>
    <td>手順的強度 + モジュール内の機能間でデータの受け渡し</td>
    <td bgcolor="87C380"></td>
    <td rowspan="5"></td>
  </tr>
  <tr>
    <td class="col1">手順的強度</td>
    <td>必ず順番に実行される複数の機能を一つのモジュールにまとめる</td>
    <td bgcolor="A5A580"></td>
  </tr>
  <tr>
    <td class="col1">時間的強度</td>
    <td>実行時のある時点で利用される複数の機能を一つのモジュールにまとめる<br>
        (機能間の関連は不問)</td>
    <td bgcolor="C38780"></td>
  </tr>
  <tr>
    <td class="col1">論理的強度</td>
    <td>論理(≠機能)的に関連のある機能を一つのモジュールにまとめ、<br>どの機能を使用するかを引数により決定する</td>
    <td bgcolor="E16980"></td>
  </tr>
  <tr>
    <td class="col1">暗号的強度</td>
    <td>無関係の機能を一つのモジュールにまとめる</td>
    <td bgcolor="FF4B80">弱</td>
  </tr>
</table>

<h3>モジュール結合度</h3>
モジュール間の依存度を表す。モジュール結合度が弱いほど、モジュールの切り出し・再利用が容易となる。
<table>
  <tr class="row1">
    <td class="col1">区分</td>
    <td>説明</td>
    <td colspan="2">モジュール結合度</td>
  </tr>
  <tr>
    <td class="col1">データ結合</td>
    <td>モジュール間で、構造を持たない引数を受け渡す</td>
    <td bgcolor="4BFF80">弱</td>
    <td>構造化設計の目標</td>
  </tr>
  <tr>
    <td class="col1">スタンプ結合</td>
    <td>モジュール間で、構造を持つ引数(構造体など)を受け渡す<br>
        (不要なデータを全く含まない場合は「データ結合」に分類される)</td>
    <td bgcolor="6FDB80"></td>
    <td rowspan="5"></td>
  </tr>
  <tr>
    <td class="col1">制御結合</td>
    <td>相手のモジュールの機能に影響を与える制御情報<br>(機能コード、スイッチなど)を受け渡す</td>
    <td bgcolor="93B780"></td>
  </tr>
  <tr>
    <td class="col1">外部結合</td>
    <td>構造を持たない大域データを複数のモジュールで共用する</td>
    <td bgcolor="B79380"></td>
  </tr>
  <tr>
    <td class="col1">共通結合</td>
    <td>構造を持つ大域データを複数のモジュールで共用する</td>
    <td bgcolor="DB6F80"></td>
  </tr>
  <tr>
    <td class="col1">内部結合</td>
    <td>あるモジュールが別のモジュールの内容・命令を直接参照・使用する</td>
    <td bgcolor="FF4B80">強</td>
  </tr>
</table>

<h2>gotoレスプログラミング</h2>
「構造化プログラミング」の前年にダイクストラが、"Go To Statement Considered Harmful"(Go To 文は有害と見なされる)<br>
という記事を投稿したことにより、goto文の排除こそが構造化プログラミングであるとの誤解も根強い。<br>
しかし、goto文の安易な使用がプログラムの構造を破壊し、構造化の妨げとなることは事実であり、<br>
構造化とgotoの排除はともにプログラム構造の明快化に寄与すると言える。<br>
<br>
即ち、gotoレスを構造化の指標(の一部)とすることは合理的であり、多くの現場では(構造化を志向していない場合も含め)gotoの使用を意図的に制限している。<br>
(深いネストからの脱出や、エラー処理など一定の用途は存在するが、そもそもトップダウン設計の下ではそのような深いネスト自体が忌避される。)<br>
goto同様の無条件分岐であるbreak文、continue文も論理構造の破壊につながることから、安易な使用は控えるべきである。<br>
<br>
また、オブジェクト指向言語においては
<a href="TIPS/C%E3%83%BBC++/[C++]%E4%BE%8B%E5%A4%96%E5%87%A6%E7%90%86.html">例外処理</a>
や
<a href="TIPS/C%E3%83%BBC++/[C++]%E5%9C%B0%E8%94%B5%E3%82%A4%E3%83%B3%E3%82%B9%E3%82%BF%E3%83%B3%E3%82%B9.html">RAII</a>
を利用できることから、gotoが必要となるケースは皆無である。<br>
(例外処理は関数呼び出しを跨いだ「大域脱出」ができるため、gotoよりも強力である。「去勢されたgoto」と呼ばれることもあるが、例外処理の本分はジャンプではなくエラーの体系的な処理である。)<br>

</body>
</html>

