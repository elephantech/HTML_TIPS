<!DOCTYPE html>

<html lang="ja">
<!-- --------------------------------------
head
--------------------------------------- -->
<head>
<meta content="text/html" charset="utf-8" http-equiv="Content-Type" />

<!-- 基準URI -->
<base href="file:///G:/共有ドライブ/098-all-employees/tips/HTML_TIPS/">

<!-- スタイルシート -->
<link rel="stylesheet" href="_Assets/Sytle001.css" type="text/css">

<!-- スクリプト -->
<!-- タイトル表示 -->
<script src="_Assets/MakeTitle.js" type="text/javascript"></script>
<!-- 目次表示 -->
<script src="_Assets/MakeToc_L.js" type="text/javascript"></script>



</head>

<!-- --------------------------------------
body
--------------------------------------- -->
<body>
<!-- ページタイトル(ページ内表示) -->
<span id="title"></span>

<!-- 出典・関連ページ -->
<h5>出典 :</h5>

<a href="https://ja.wikipedia.org/wiki/%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%B3%E7%AE%A1%E7%90%86%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0">バージョン管理システム - Wikipedia</a><br>

<h5>関連 :</h5>
<a href="TIPS/バージョン管理システム(VCS)/分散型VCS.html">分散型VCS</a><br>

<!-- 目次 -->
<h5>目次 :</h5>
<div id="toc"></div>

<hr>

<!-- 本文ここから -->


<h2>バージョン管理システム(VCS)とは</h2>

ファイルおよびフォルダの変更履歴を保持するシステム。VCSを用いることでファイル・フォルダが
<ul>
<li>いつ</li>
<li>誰によって</li>
<li>何故</li>
<li>どのように</li>
</ul>
変更されたのかを追跡でき、
<ul>
<li>不具合があった場合に以前のバージョンに巻き戻す</li>
<li>ある人が施した変更を上書きしてしまうことを防ぐ</li>
</ul>
ことができる。

<h3>VCSを用いない場合</h3>
<img src="_Img/VCS/VCS_basics/01.png"><br>
<ul>
<li>すべてのバージョンのファイル(またはフォルダ)をそのまま保存することになるため、ディスクを圧迫する</li>
<li>誰かが保存した後に、同じバージョンを保存すると、上書きされたバージョンは(バックアップが無ければ)永久に失われる(図のVer.0.4)</li>
<li>枝分かれしたバージョンがどこから(どの親から)分岐したのかは、別途記録を残しておく必要がある(図のVer.0.5a / 0.5b)<br>
⇒ 運用でカバーする必要がある</li>
<li>バージョン間の比較には、別途Diffツールを用いる必要がある</li>
</ul>

<h3>VCSを用いた場合</h3>
<img src="_Img/VCS/VCS_basics/02.png"><br>
<ul>
<li>リポジトリには「バージョン間の差分」が保持されており、ディスクを無用に圧迫しない</li>
<li>「バージョン間の差分」は履歴(コミットログ)として保存されており、随時比較できるとともに、以前のバージョンに戻すことが可能</li>
<li>誰か(Bさん)が保存(コミット)した後に、同じ個所を変更したものをコミットしようとしても、競合(BさんとCさん)を解決しなければコミットが許されない<br>
⇒ Bさんの加えた変更は履歴として残り、Bさんの変更が上書きされる場合も合理的に解決される</li>
<li>バージョンの分岐(ブランチ)が記録として残り、本流と支流の区別が明確になるとともに、親を特定できる</li>
<li>バージョン間の差異は、ツールに統合された形で履歴とともに参照できる<br>
⇒ 特定のバージョン同士の比較も可能</li>
</ul>

<h2>代表的なVCSの例</h2>
分散型VCSについては <a href="TIPS/バージョン管理システム(VCS)/分散型VCS.html">分散型VCS</a> を参照のこと。<br>
<table>
    <tr class="row1">
        <td class="col1"></td>
        <td>名称</td>
        <td>ライセンス</td>
        <td>特徴</td>
    </tr>
    <tr>
        <td rowspan="3" class="col1">集中型</td>
        <td>CVS</td>
        <td>フリー</td>
        <td></td>
    </tr>
    <tr>
        <td>Subversion (SVN)</td>
        <td>フリー</td>
        <td>CVSの改良版として開発され、現在も広範に用いられている</td>
    </tr>
    <tr>
        <td>Visual SourseSafe</td>
        <td>プロプライエタリ</td>
        <td>MSVSとの連携が重視されている</td>
    </tr>
    <tr>
        <td rowspan="2" class="col1">分散型</td>
        <td>Git</td>
        <td>フリー</td>
        <td>現在最も広範に用いられるVCSのひとつ</td>
    </tr>
    <tr>
        <td>Mercurial</td>
        <td>フリー</td>
        <td>Subversionと共通する簡便なUIをもつ</td>
    </tr>
</table>

<h2>基本的な手順</h2>
<img src="_Img/VCS/VCS_basics/03.png"><br>

<h3>プロジェクトの立ち上げ</h3>
<ol>
    <li>バージョン管理対象とするファイルの構成を決定する<br>
    (後から変更も可能だが、混乱を防ぐためにはこの時点で確定しておいたほうがよい)</li>
    <li>1. のファイル(群)をVCSにチェックイン(インポート)し、バージョン管理下に置く</li>
</ol>

<h3>ファイルの編集</h3>
<ol>
    <li>(初回のみ)リポジトリから任意の場所にチェックアウトを行う<br>
    以後、この場所が「作業コピー」となる</li>
    <li>作業コピーを更新(最新版に同期)する</li>
    <li>作業コピーを編集する</li>
    <li>コミットを行い、作業コピーへの変更をリポジトリに反映する</li>
    <li>2. ～ 4. を繰り返す</li>
</ol>

<h2>VCSにおける概念</h2>
以後ファイルおよびフォルダをまとめて「ファイル」と称する。<br>

<h3>リポジトリ</h3>
バージョン管理対象のファイルを保管するディレクトリ。リポジトリの作成は主にプロジェクト管理者が担当する。<br>
すべての作業者が共通で参照し、編集内容を反映する先となる。

<h3>チェックイン(またはインポート)</h3>
ファイルをリポジトリに登録し、バージョン管理の対象とすること。

<h3>チェックアウト</h3>
バージョン管理されたファイルをローカルマシンにダウンロードすること。チェックアウトは原則1回でよい。<br>
(以後は更新により、ローカルをリポジトリに同期する)

<h3>作業コピー</h3>
ローカルマシンにダウンロードした、リポジトリのコピー。<br>
この作業コピーに対して編集を行う。

<h3>コミット(またはチェックイン)</h3>
作業コピーに加えた変更をリポジトリに反映(確定)すること。これにより、リポジトリ上のファイルが更新される。<br>
変更(コミット)した理由、変更の概要をコミットメッセージとして残すのが一般的。

<h3>更新(アップデート)</h3>
作業コピーを最新、または指定したリビジョンに更新すること。<br>
ファイルの変更は最新バージョンに対して行うのが原則であるため、<b>変更前には必ず更新を行うこと</b>。<br>
(更新処理を行わない限り、ローカルのファイルは自動的には最新化されない)

<h3>リビジョン</h3>
ファイルの世代を(主に)通し番号で表したもの。これにより、ファイルの世代を特定できる。<br>
コミットによって1つ増え、リビジョンとコミットは1対1で関連付けられる。「バージョン」と概ね同義。<br>
リビジョンを通し番号ではなくハッシュ値で管理するVCSも存在し、その場合はコミット前後でハッシュ値が全く異なるものとなる。<br>
いずれにせよ、リビジョンは一つのリポジトリ内で一意であることが原則。

<h3>ログ</h3>
リビジョン( = コミット)履歴の一覧。ログを参照することで、どのファイルが、誰によって、いつ、どのように変更されたのかを追跡できる。

<h3>ステージング</h3>
ファイルをバージョン管理下に置くこと。<br>
作業コピーとなっているフォルダ上にファイルを配置しただけでは、その後コミットを行ったとしてもそのファイルはリポジトリには追加されない。<br>
配置したファイルを「追加」することでバージョン管理下に置かれ(ステージング)、コミットによってリポジトリに反映される。<br>
同様に、ファイルを削除する場合もバージョン管理下から抜く「削除」(ステージから降ろす)処理が必要。

<h3>トランク(trunk : 幹) / ブランチ(branch : 枝)</h3>
開発を行う上で、系統が枝分かれすることがある。別れた枝のことをブランチと呼び、ブランチ名を設定できる。<br>
対して、主流となる系統(枝分かれの元)をトランクまたはマスター(master)と呼ぶ。<br>
ブランチに対してさらにブランチを作成することができる。また、トランクもブランチである。<br>
(すなわち、トランクを含めたブランチ同士に優劣はない)

<h3>タグ</h3>
担当者が特定のリビジョン(スナップショット)に対して付与する別名。正式なバージョン名が決定した際などに用いる。<br>
更新などの際には、リビジョン番号だけでなくタグを用いてリビジョンを指定できる。<br>

<img src="_Img/VCS/VCS_basics/04.png"><br>

<h3>衝突・競合(コンフリクト)</h3>
あるファイルに加えた変更に対して、別の人が同じ個所を変更しておりコミットできないこと。<br>
例えば、AさんとBさんがともにリビジョン1をチェックアウトし、同じファイルの同じ個所に対して変更を行った場合、<br>
先にコミットしたAさんはほかに何も行う必要は無いが、Bさんが遅れてコミットしようとしても、<br>
(Aさんの加えた変更が上書きされることを防ぐため)競合が発生してコミットできない。<br>
この場合、Bさんが取る手順は、
<ol>
    <li>手元のファイルを(Aさんの変更が反映されたリビジョン2に)更新する</li>
    <li>(ファイルを編集していた場合)競合の解消が求められるため、<br>
    Aさんの変更、自身の変更のいずれか、または両方を残すのかを選択する<br>
    (不都合が無いよう、PLやAさんとの合意をとる必要がある)</li>
</ol>
となる。<br>
<br>
競合の解決は(特に慣れないうちは)煩雑で危険を伴うため、そもそも競合が発生しないように、
<ol>
    <li>ファイルの編集は(そのブランチの)最新版に対して行う<br>
    (編集前に更新を徹底する)
    <li>同一のファイルを複数人で編集しないよう、PLが役割を調整する</li>
    <li>担当者ごとにブランチを作成する
</ol>
とする必要がある。

<h3>併合(マージ)</h3>
(多くの場合は)あるブランチに、別のブランチとの差分を取り込むこと。<br>
マージされたブランチは、それまで自身に加えられた変更と、取り込んだ別ブランチの変更が混在することとなる。<br>
マージの際には不整合が無いよう両者の比較(および競合の解決)を十分に行う必要がある。<br>
マージ対象はブランチに限らず、特定のリビジョン、またはタグでも可能である。

</body>
</html>
